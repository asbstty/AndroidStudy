//
//作者：flyingleaf
//
//作用：简单测试printf的类型，主要是查看那些变态的printf参数
//
//日期：2004-12-27
//
//
#include <stdio.h>
#include <string.h>

int main()
{
	 float d=3.14;
	 printf("d=%.10e\n",d); //这里输出的6位以后的都是垃圾数据了，不准确
	 char ch[20];
	 strcpy(ch,"123456780123");
	 int n = 2,m = 10;
	 //*.* 呢，前边的*定义的是总的宽度，后边的定义的是输出的个数。
	 //如果后边的比前边的小，则使用空格在左侧补够m位。
	 printf("%*.*s\n",m,n,ch);//这里输出“        12”
	 printf("%*.*s\n",n,m,ch);//这里输出“1234567890”
	 //补充，如果strlen(ch) < m的话，就输出strlen位 例如：
	 strcpy(ch, "1234678");
	 //这里结尾使用个hh作为输出，是为了更好的显示出输出12345678后到底光标到了那里
	 printf("%*.*shh\n",m,n,ch);//这里输出“        12hh”
	 printf("%*.*shh\n",n,m,ch);//这里输出“12345678hh”
	 int y = 456;
	 //这里的#8d,保持宽度的，如果不够8位，就在左侧用空格补够
	 //如果超过8位，则有几位就输出几位。
	 printf("%#8d\n%#8x\n%#8o\n", y,y,y);
	 printf("%#3d\n%#3x\n%#3o\n", y,y,y);
	 printf("%#1d\n%#1x\n%#1o\n", y,y,y);
	 //这里的.8d估计大家都不陌生了吧?就是不够8位的时候左侧使用0补够
	 //同样,如果超过8位就有几位输出几位
	 printf("%.8d\n%.8x\n%.8o\n", y,y,y);
	 //这里的*d估计有的人有点陌生,其实可以看作是#6d,效果是一样的.
	 printf("%*d\n",6,y);
	 //这里的%+6d中的+号有俩意思:一、输出的数字前面有+号，二、不够6位左侧补空格
	 printf("%+6d\n",y);
	 //这连个和上面的%+6d的意思基本一样，但是如果y的位数+1没有6大，就用0补，但是个数是不超过
	 //6前面的0的个数。具体效果可以运行下看看
	 printf("%+006d\n",y);
	 printf("%+0006d\n",y);
	 //补充上面，如果6比y的位数小的话，只输出+号和y本身
	 //如果没有+号的话，则是使用0补充够6位 例如：
	 printf("%06d\n",y);//输出“000456”
	    //这里的-号是右侧补空格的意思 为了明显起见，我们仍旧使用hh作为结尾。
	 printf("%-6dhh\n",y);
	 //当然，如果这里的2没有y的位数大的话，就直接输出y，然后输出hh
	 //这里的-号仅仅是右侧补空格的意思
	 printf("%-2dhh\n",y);
	 //一个利用printf来输出的例子
	 int len = 0;
	 //这里%n的意思是将%n前的字符串的长度符给len：
	 //下面的例子是8 = strlen("hh") + strlen("123456");
	 printf("hh%s%n \n", "123456",&len);
	 printf("len=%d\n", len);
	 //本来不打算写他了 但是带上吧
	 //简单说明吧：.0f是小数点后0位，不带点 #.-0f就是带点 但是也是0位
	 //而%g则省略所以的无效的0 如果没有小数，则不带点 #g则一个0都不可以少！
	 printf("%.0fhh\n%#.0fhh\n%ghh\n%#ghh\n", 3.0,3.0,3.0,3.0);

	 //输出7个空壳再输出%号。不同编译器可能有差异，以前在微软的VC中试验，不是这个结果，是只有一个%。 
	 printf("%*%\n", 8);
    
    return 0;
}